version: '3.8'  # The dialect of Docker Compose we are using

services:       # A list of the "machines" we want to run
# Service 1: Your Public Website (The "Hello World" Page)
  my-web-server:                # Name of our service
    build: ./app             # üëà Build the Dockerfile in the 'app' folder
    container_name: production-website
    restart: always
    ports:
      - "80:5000"
    depends_on:
      - db:  # Wait for the database to start first
          condition: service_healthy
    environment:
      - DB_HOST=db
      - DB_NAME=company_db
      - DB_USER=admin
      - DB_PASS=&&1234HT            # üëà Map VM Port 80 to Container Port 5000 (Flask)
    # We don't need volumes for code anymore because it's baked into the image

# 2. The Data (PostgreSQL)
  db:
    image: postgres:13-alpine
    container_name: company-database
    restart: always
    environment:
      POSTGRES_DB: company_db
      POSTGRES_USER: admin
      POSTGRES_PASSWORD: "&&1234HT"
    volumes:
      - postgres-data:/var/lib/postgresql/data  # Persistence!
# ‚¨áÔ∏è NEW: ADD THE HEALTH CHECK ‚¨áÔ∏è
    healthcheck:
      test: ["CMD-SHELL", "pg_isready -U admin"] # Checks if Postgres is accepting connections
      interval: 5s
      timeout: 5s
      retries: 5

# Service 2: The Monitoring Dashboard (Uptime Kuma)
  uptime-kuma:
    image: louislam/uptime-kuma:1
    container_name: monitoring-dashboard
    restart: always
    ports:
      - "3001:3001"  # Access this on Port 3001
    volumes:
      - uptime-kuma-data:/app/data

# Define a storage volume for the dashboard so it remembers data if it restarts
volumes:
  uptime-kuma-data:
  postgres-data: # Create a permanent storage box for the DB
